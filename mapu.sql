/*
 Navicat Premium Data Transfer

 Source Server         : form
 Source Server Type    : MySQL
 Source Server Version : 80025
 Source Host           : localhost:3306
 Source Schema         : mapu

 Target Server Type    : MySQL
 Target Server Version : 80025
 File Encoding         : 65001

 Date: 21/06/2025 00:53:55
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '文章ID',
  `user_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '作者ID',
  `category_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '类别ID',
  `title` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '文章标题',
  `summary` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '文章简介',
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '文章内容',
  `status` tinyint(0) NOT NULL COMMENT '状态：0-审核中，1-已发布，2-审核未通过，3-草稿',
  `create_time` datetime(0) NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '创建时间',
  `update_time` datetime(0) NULL DEFAULT CURRENT_TIMESTAMP(0) ON UPDATE CURRENT_TIMESTAMP(0) COMMENT '更新时间',
  `publish_time` datetime(0) NULL DEFAULT NULL COMMENT '发布时间',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `user_id`(`user_id`) USING BTREE,
  INDEX `category_id`(`category_id`) USING BTREE,
  CONSTRAINT `article_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE CASCADE ON UPDATE RESTRICT,
  CONSTRAINT `article_ibfk_2` FOREIGN KEY (`category_id`) REFERENCES `article_category` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '文章表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES ('08860d1b-883b-4997-a3b8-464f90569dd5', 'abdb3d00-749e-4189-8370-0f66e10fb728', 'cat007', '外媒：卫星图像显示，美数十架军机不再停放卡塔尔美空军基地，美国防官员回应', '【环球网报道】据法新社当地时间19日报道，在美国权衡是否介入以伊冲突之际，最新卫星图像显示，美国数十架军机已不再停放在位于卡塔尔的美军乌代德空军基地停机坪上。法新社分析认为，这一调动可能是为防范伊朗未来可能发动的空袭。', '【环球网报道】据法新社当地时间19日报道，在美国权衡是否介入以伊冲突之际，最新卫星图像显示，美国数十架军机已不再停放在位于卡塔尔的美军乌代德空军基地停机坪上。法新社分析认为，这一调动可能是为防范伊朗未来可能发动的空袭。\n\n法新社援引美国商业卫星公司星球实验室发布的图像并进行对比分析称，6月5日，乌代德基地的停机坪上仍停有包括C-130“大力神”运输机在内的数十架军机；而在6月19日拍摄的图像中，仅可见3架军机。\n\n2025年6月5日（左）和6月19日（右）美军乌代德空军基地卫星图像  图源：外媒报道配图\n\n一名美国国防官员拒绝就具体军事部署位置置评，仅对法新社表示，“我们仍然致力于在确保行动安全的同时，以最高水平的战备状态、杀伤力和专业精神执行我们的任务。”\n\n兰德公司防务研究员马克•施瓦茨就此表示，乌代德基地的人员、飞机和设施将“极其脆弱”，因为其地理位置靠近伊朗。\n\n同日（19日），美国驻卡塔尔大使馆发出安全警告，限制大使馆工作人员进入位于卡塔尔的美军乌代德空军基地，并敦促其工作人员和在卡塔尔的美国公民“提高警惕”、谨慎行动。\n\n另据白宫公布的日程安排显示，美国总统特朗普将在未来几天每天听取国家安全委员会针对当前以色列与伊朗冲突的情报简报。特朗普每天都在白宫战情室与国家安全官员会面，考虑是否加入以色列针对伊朗的行动。', 1, '2025-06-20 16:50:22', '2025-06-20 16:50:22', NULL);
INSERT INTO `article` VALUES ('09c79bb4-5fac-4cbb-8c3e-de18fa214c5a', 'abdb3d00-749e-4189-8370-0f66e10fb728', 'cat007', '英媒：英议员称斯塔默最终可能会允许美国利用英国军事基地打击伊朗', '据英国天空新闻网20日报道，曾任英国工党代理党魁的议员哈曼在节目中表示，英国首相斯塔默最终可能会允许美国总统特朗普动用英国军事基地对伊朗发动打击。', '【环球网报道】据英国天空新闻网20日报道，曾任英国工党代理党魁的议员哈曼在节目中表示，英国首相斯塔默最终可能会允许美国总统特朗普动用英国军事基地对伊朗发动打击。\n\n报道称，哈曼表示，作为工党成长起来的政治世代，斯塔默这代人深受“反对伊拉克战争”情绪的影响，但他仍有可能作出上述决定，“这对他而言是一个巨大的改变”。\n\n报道提到，当被问及英国最终是否会允许美国飞机使用英国位于塞浦路斯和迪戈加西亚岛的军事基地但不提供任何其他支持时，哈曼回答说，“正是如此”。\n\n特朗普与斯塔默16日在七国集团（G7）峰会期间敲定了两国间的贸易协议。哈曼表示，在这种情况下，斯塔默很难拒绝向特朗普开放空军基地。\n\n另据英国《卫报》报道，英国外交大臣拉米19日在华盛顿与美国国务卿鲁比奥会面。拉米表示，双方讨论了“如何通过协议避免冲突加深”，并称“现在存在一个在未来两周内达成外交解决方案的窗口期”。', 1, '2025-06-20 14:43:00', '2025-06-20 14:43:00', NULL);
INSERT INTO `article` VALUES ('0caf282c-fa9b-4f05-b971-4b0595613fb4', 'abdb3d00-749e-4189-8370-0f66e10fb728', 'cat007', '巴黎航展“尴尬”一幕：法国总理登上“阵风”战斗机，被卡驾驶舱内无法脱身', '【环球网报道】俄罗斯《消息报》网站19日援引法媒消息报道称，法国总理弗朗索瓦·贝鲁近日在巴黎-布尔歇国际航空航天展览会（巴黎航展）期间登上“阵风”战斗机时，意外被卡在驾驶舱里，无法自行脱身。', '【环球网报道】俄罗斯《消息报》网站19日援引法媒消息报道称，法国总理弗朗索瓦·贝鲁近日在巴黎-布尔歇国际航空航天展览会（巴黎航展）期间登上“阵风”战斗机时，意外被卡在驾驶舱里，无法自行脱身。\n\n贝鲁近日在巴黎航展期间登上“阵风”战斗机，却意外被卡驾驶舱无法自行脱身。图源：外媒报道配图\n\n“在参观布尔歇航展期间……贝鲁登上了一架法国‘阵风’战斗机。然而，出现了小插曲：总理被卡在驾驶舱内，无法自行离开飞机，这在网络上引发大量调侃。”法媒描述称。\n\n《消息报》称，展示“阵风F5”战斗机本是此次活动的重点，但贝鲁这一趣事却反而吸引了公众所有注意力。\n\n另据“今日俄罗斯”（RT）报道，全体人员随后紧急展开营救，最终这场“解困”行动顺利完成。\n\n第55届巴黎-布尔歇国际航空航天展览会（巴黎航展）16日在巴黎近郊开幕，本届展会将持续至22日，吸引了来自48个国家和地区的近2400家参展商。创始于1909年的巴黎航展是世界上规模最大和最负盛名的国际航空航天展会之一。', 0, '2025-06-20 15:10:29', '2025-06-20 16:26:30', NULL);
INSERT INTO `article` VALUES ('1d1310dd-932f-4e69-9131-d03fd3b57531', 'abdb3d00-749e-4189-8370-0f66e10fb728', 'cat003', '黄晓明未进入上戏博士拟录取名单，本人回应：明年再战', '5月12日，上海戏剧学院招生网公布《上海戏剧学院2025年博士研究生（申请-考核制）考生复试注意事项及名单》，复试名单中出现演员黄晓明、金世佳的名字。', '5月12日，上海戏剧学院招生网公布《上海戏剧学院2025年博士研究生（申请-考核制）考生复试注意事项及名单》，复试名单中出现演员黄晓明、金世佳的名字。\n复试名单显示，黄晓明的报考研究方向为“艺术管理/戏剧策划”，金世佳的报考研究方向为“表导演创作”，两者均备注“同等学力加试”。\n\n\n6月20日，上海戏剧学院招生网公布《2025年上海戏剧学院博士研究生拟录取名单》，金世佳以278.84分的总成绩，成功被录取。但遗憾的是，并未在上面找到黄晓明的名字。\n\n随后，红星新闻记者联系上黄晓明，对于落榜一事，他称：“明年再战。”\n\n红星新闻记者 张世豪 编辑 曾琦', 1, '2025-06-20 14:45:11', '2025-06-20 14:45:11', NULL);
INSERT INTO `article` VALUES ('37e6e538-908d-4d53-a122-a3f066df78c2', 'abdb3d00-749e-4189-8370-0f66e10fb728', 'cat007', '“最强硬表态”！外媒：克宫称，若哈梅内伊遇刺，俄方将作出“非常负面”的反应', '【环球网报道】据英国天空新闻网20日报道，克里姆林宫发言人、俄罗斯总统新闻秘书佩斯科夫近日在接受采访时表示，伊朗政权发生更迭是“不可接受的”。如果伊朗最高领袖哈梅内伊遇刺，这将“打开潘多拉魔盒”，而俄罗斯将作出“非常负面”的反应。', '【环球网报道】据英国天空新闻网20日报道，克里姆林宫发言人、俄罗斯总统新闻秘书佩斯科夫近日在接受采访时表示，伊朗政权发生更迭是“不可接受的”。如果伊朗最高领袖哈梅内伊遇刺，这将“打开潘多拉魔盒”，而俄罗斯将作出“非常负面”的反应。\n\n佩斯科夫近日接受英国天空新闻网采访。图源：外媒\n\n“局势极度紧张，对该地区乃至全球而言都很危险。” 佩斯科夫称，“若冲突参与方进一步扩大，可能会更加危险……这只会在该地区引发新一轮对抗与紧张局势升级”。\n\n天空新闻网称，这是克里姆林宫迄今为止就以伊冲突发出的最强硬表态。\n\n“（伊朗政权发生更迭），这是无法想象的。（而且）应该是不可接受的，甚至谈论这一点对每个人来说都应该是不可接受的。”佩斯科夫称。\n\n报道称，当被问及若哈梅内伊遇刺俄罗斯将作何反应，佩斯科夫回答说“非常负面”。他没有提到俄罗斯具体会采取何种行动，但表示此举将激起“来自伊朗内部”的行动。“这将导致伊朗国内滋生极端主义情绪，那些谈论（刺杀哈梅内伊）的人应该牢记，他们正在开启潘多拉魔盒。”佩斯科夫说。\n\n报道提到，美国总统特朗普18日曾表示，他拒绝俄罗斯总统普京提出的帮助调解伊朗与以色列冲突的提议，他认为普京应首先专注于促成在乌克兰的停火。佩斯科夫对此回应称，并不认为特朗普的言辞具侮辱性，并补充说“每个人的表达方式不同。特朗普总统有他独特的说话方式和语言（风格）。我们相当宽容，也希望每个人都能宽容我们”。\n\n以伊冲突近日持续升级。多名美国匿名官员15日向多家媒体披露，美国总统特朗普否决了以色列刺杀伊朗最高领袖哈梅内伊的计划。不过，以色列总理内塔尼亚胡当天对此不置可否，另有以方官员称报道系“捏造”。', 1, '2025-06-20 14:45:59', '2025-06-20 14:45:59', NULL);
INSERT INTO `article` VALUES ('8bb4c2ad-8d46-42c9-af4c-99ccede8b7b9', '335a31c0-e1bf-4461-834e-c18aa6c18585', 'cat009', '到底什么是聊骚?', '到底什么是聊骚?', '我们一般认为正常男女关系聊天不应该聊骚，但是到底怎么定义这个行为呢，我对此有些疑惑。\n\n以我仅有的经历和十分片面的理解，在双方可以接受的范围内，男女关系中适当的x话题确实是可以快速拉近距离的，因为我初中谈过一次，她就是比我还懂得多得多，两个人聊这些东西大大加速了暧昧的进度（青春期嘛，啥都好奇），当然我也有同学认为恋爱应该保证纯粹，不应该涉及x话题，否则就十分下头。\n\n我认为这些话语或者交流类似于调qing，假如是两个人关系到了一定程度，那就是增进感情，但是假如没到那个程度就是对对方的骚扰和不尊重。另外我认为同一句话，也有分怀有爱意和恶意的两张区别，显然后者是令人反感的\n\n但是到底什么程度的关系可以两人可以接受什么限度的话题，恰恰又是双方没法互相了解或界定的。或者说其实整个问题就是如何保证不越界。可能一个人是不介意这种话题（我有同学一群人玩时，连女生讲各种h都不带眨眼的，开玩笑那种），但另一个人完全不愿意听到这种话题（有同学就是认为结合是十分恶心的行为）。\n\n服了xhs了，我还想在小红书也问问的，毕竟就xhs会女生多点了，结果怎么改都ban我', 1, '2025-06-20 14:52:37', '2025-06-20 14:53:52', NULL);
INSERT INTO `article` VALUES ('9bad0c72-9f93-4979-88e1-79d8fc6df127', 'b98070a4-ca31-4739-9d3f-d239b6f36a34', 'cat004', '【Android学习】四大组件', 'Activity 是 Android 应用的核心组成部分之一，主要负责展示用户界面，响应用户的交互操作。每个 Activity 通常对应一个独立的屏幕，用户可以在多个 Activity 之间进行切换。', '一、Activity：用户界面的核心\nActivity 是 Android 应用的核心组成部分之一，主要负责展示用户界面，响应用户的交互操作。每个 Activity 通常对应一个独立的屏幕，用户可以在多个 Activity 之间进行切换。\n\n1.功能\n作为应用的 UI 界面。\n处理用户交互，响应用户的点击、输入等操作。\n管理 Activity 的生命周期，控制界面的启动、暂停、销毁等状态。\n2.生命周期\n2.1生命周期方法\nonCreate()：Activity 被创建时调用，通常用于进行初始化操作，比如设置布局、初始化 UI 元素、绑定数据等。\nonStart()：Activity 正在启动，并即将变为可见状态，但此时还没有获取焦点。\nonResume()：Activity 开始与用户交互，并成为用户当前操作的界面。\nonPause()：Activity 正在停止与用户交互，通常用户切换到另一个 Activity 时会调用，需在此释放一些非必要的资源。\nonStop()：Activity 不再可见，进入后台，通常此时应释放所有资源，以防止内存泄露。\nonRestart()：Activity 从不可见状态重新进入可见状态（从后台切回前台）时调用。\nonDestroy()：Activity 被销毁时调用，进行清理工作，释放所有资源。\n 2.2生命周期流程图\n\n\n3.启动模式\n3.1 标准模式 (standard)\n默认模式，每次启动一个 Activity，都会创建一个新的实例。\n应用场景：一般用于不需要重复检查 Activity 实例的普通页面。\n3.2 单顶模式 (singleTop)\n如果任务栈的顶部已经存在该 Activity 的实例，则不会重新创建实例，而是复用栈顶的实例。\n应用场景：常用于详情页面、设置页面等多次打开，但不希望重复创建实例的场景。\n3.3 单任务模式 (singleTask)\n在任务栈中只会存在一个实例，如果任务栈中已经存在该 Activity，则复用此实例，并清除其上的所有 Activity。\n应用场景：用于需要保证某个 Activity 在任务栈中始终唯一的场景，如主页面、导航页面。\n3.4 单实例模式 (singleInstance)\n在整个系统中只会存在一个该 Activity 的实例，无论是哪个应用启动此 Activity，都会复用同一个实例。\n应用场景：用于特殊应用场景，比如独占全局的 Activity，例如系统的拨号界面等。\n4. Activity之间的通信\nActivity 之间的通信主要通过 Intent 实现，Intent 是 Android 中用来启动组件（如 Activity、Service）和传递数据的重要机制。\n\n4.1 启动另一个 Activity\nIntent intent = new Intent(MainActivity.this, SecondActivity.class);\nstartActivity(intent);  // 启动 SecondActivity\nAI写代码\njava\n运行\n4.2 启动并传递数据\nIntent intent = new Intent(MainActivity.this, SecondActivity.class);\nintent.putExtra(\"key\", \"value\");\nstartActivity(intent);\nAI写代码\njava\n运行\n在 SecondActivity 中接收数据：\n\nString value = getIntent().getStringExtra(\"key\");\nAI写代码\njava\n运行\n4.3 返回结果\n有时我们希望启动一个 Activity，并从中获取返回结果。可以使用 startActivityForResult() 来启动，并在 onActivityResult() 中接收返回的数据。\n\n启动并期待返回结果：\n\nIntent intent = new Intent(MainActivity.this, SecondActivity.class);\nstartActivityForResult(intent, REQUEST_CODE);\nAI写代码\njava\n运行\n在 SecondActivity 中返回结果：\n\nIntent intent = new Intent();\nintent.putExtra(\"result\", \"value\");\nsetResult(RESULT_OK, intent);\nfinish();\nAI写代码\njava\n运行\n在 MainActivity 中接收返回结果：\n\n@Override\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    if (requestCode == REQUEST_CODE && resultCode == RESULT_OK) {\n        String result = data.getStringExtra(\"result\");\n        // 处理结果\n    }\n}\nAI写代码\njava\n运行\n5. Activity的UI管理\nActivity 是 UI 展示的核心，主要通过 XML 布局文件和代码相结合的方式管理界面。每个 Activity 通常对应一个布局文件，布局文件中定义了 UI 组件的位置和样式，代码中处理这些组件的行为。\n\n5.1 设置布局\n在 onCreate() 方法中通过 setContentView() 设置布局：\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);  // 设置对应的布局文件\n}\nAI写代码\njava\n运行\n5.2 访问 UI 元素\n通过 findViewById() 访问布局中的 UI 组件：\n\nButton button = findViewById(R.id.myButton);\nbutton.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        // 按钮点击事件\n    }\n});\nAI写代码\njava\n运行\n6.注意事项\n管理好 Activity 的生命周期，确保资源的合理分配与回收，避免内存泄漏。\n注意横竖屏切换时生命周期的变化，需要妥善处理。\n二、Service：后台处理任务\nService 是 Android 的后台组件，用于在不需要用户界面交互的情况下执行长时间运行的任务，例如音乐播放、下载文件等。Service 是在后台运行的，不会直接与用户交互。\n\n1.功能\n执行后台操作，如网络请求、播放音频、同步数据等。\n可以与 Activity 进行交互，但没有用户界面。\n2. Service的分类\nAndroid 中 Service 分为三种主要类型，每种类型适合不同的应用场景。\n\n2.1 普通服务（Started Service）\nStarted Service 是通过调用 startService() 方法启动的。服务一旦启动，即使启动它的 Activity 被销毁，服务仍然可以在后台继续运行，直到调用 stopSelf() 或 stopService() 来停止服务。\n\n启动方式：startService() 或 Context.startForegroundService()\n停止方式：调用 stopSelf() 或 stopService()。\n典型场景：如音乐播放、文件下载等需要持续运行的任务。\nIntent intent = new Intent(this, MyService.class);\nstartService(intent);  // 启动服务\nAI写代码\njava\n运行\n2.2 绑定服务（Bound Service）\nBound Service 允许其他组件通过绑定的方式与服务交互。通过 bindService() 方法启动并绑定服务，组件可以与服务进行通信。服务在所有绑定的客户端解绑后会自动销毁。\n\n启动方式：bindService()\n停止方式：当所有绑定的客户端解绑后，服务会自动销毁。\n典型场景：如客户端与服务端的交互，或者需要与应用频繁交互的任务。\nIntent intent = new Intent(this, MyService.class);\nbindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);  // 绑定服务\nAI写代码\njava\n运行\n2.3 前台服务（Foreground Service）\nForeground Service 是一种特殊的 Started Service，它会在通知栏显示一个通知，以提高优先级，避免系统在资源紧张时优先关闭它。\n\n启动方式：Context.startForegroundService()，并在服务中调用 startForeground() 方法显示通知。\n典型场景：如音乐播放器在后台播放音乐、导航应用持续提供GPS导航等。\nIntent intent = new Intent(this, MyService.class);\nstartForegroundService(intent);  // 启动前台服务\nAI写代码\njava\n运行\n在 Service 中调用 startForeground()：\n\nNotification notification = new NotificationCompat.Builder(this, CHANNEL_ID)\n    .setContentTitle(\"Foreground Service\")\n    .setContentText(\"Running in the background\")\n    .setSmallIcon(R.drawable.ic_service)\n    .build();\nstartForeground(1, notification);  // 显示前台服务的通知\nAI写代码\njava\n运行\n3. Service的生命周期\nService 的生命周期方法与 Activity 类似，但其核心不同点在于 Service 是后台运行，不涉及用户交互。\n\n3.1 Started Service的生命周期\nonCreate()：服务创建时调用，仅调用一次，通常用于初始化服务资源。\n\nonStartCommand()：每次通过 startService() 启动服务时调用，执行具体任务的逻辑。返回值决定了系统在服务终止后的行为。\n\nSTART_STICKY：服务终止后会自动重启，适用于需要持续运行的服务（如音乐播放、下载服务）。\nSTART_NOT_STICKY：服务终止后不会自动重启，适用于不需要持续运行的短期任务。\nSTART_REDELIVER_INTENT：服务终止后会自动重启，并重新传递最后一个 Intent，适用于需要继续处理上次未完成任务的情况。\nonDestroy()：服务被销毁时调用，用于清理资源。\n\n3.2 Bound Service的生命周期\nonCreate()：服务创建时调用。\n\nonBind()：服务被绑定时调用，返回一个 IBinder 实例，用于客户端与服务通信。\n\nonUnbind()：当所有客户端解绑时调用。\n\nonDestroy()：服务销毁时调用。\n\n3. Service与线程\nService 本身运行在主线程中，任何长时间的操作（如网络请求、文件下载）应在另一个线程如果直接在 Service 中执行耗时任务，可能会阻塞 UI 线程，导致应用无响应（ANR）。因此，开发者通常使用线程池、Handler 或者 IntentService 来处理异步任务。\n\n3.1 使用线程池 (ThreadPoolExecutor) 来处理异步任务\n线程池 是一种高效的异步任务处理方式，可以管理多个并发任务。通过创建线程池，开发者可以限制同时执行的任务数量，并优化性能。\n\npublic class MyService extends Service {\n \n    private ExecutorService executorService;\n \n    @Override\n    public void onCreate() {\n        super.onCreate();\n        // 创建线程池\n        executorService = Executors.newFixedThreadPool(3);  // 设置最多3个并发线程\n    }\n \n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        // 向线程池提交任务\n        executorService.execute(new Runnable() {\n            @Override\n            public void run() {\n                // 在后台执行耗时任务，比如文件下载\n                performLongRunningTask();\n            }\n        });\n        return START_STICKY;\n    }\n \n    private void performLongRunningTask() {\n        // 模拟长时间操作\n        try {\n            Thread.sleep(5000);  // 模拟耗时任务\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n \n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        if (executorService != null) {\n            executorService.shutdown();  // 关闭线程池\n        }\n    }\n \n    @Override\n    public IBinder onBind(Intent intent) {\n        return null;  // 如果不是 Bound Service 返回null\n    }\n}\nAI写代码\njava\n运行\n\n3.2 使用 HandlerThread 和 Handler 来处理异步任务\nHandlerThread 是一个带有 Looper 的线程，用于处理与 Handler 的消息通信。它特别适合在后台执行异步任务，并且提供了消息调度的能力。\n\npublic class MyService extends Service {\n \n    private HandlerThread handlerThread;\n    private Handler handler;\n \n    @Override\n    public void onCreate() {\n        super.onCreate();\n        // 创建一个HandlerThread\n        handlerThread = new HandlerThread(\"MyServiceThread\");\n        handlerThread.start();\n        // 使用HandlerThread的Looper创建Handler\n        handler = new Handler(handlerThread.getLooper());\n    }\n \n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        // 向Handler发送任务\n        handler.post(new Runnable() {\n            @Override\n            public void run() {\n                // 在后台线程中执行任务\n                performLongRunningTask();\n            }\n        });\n        return START_STICKY;\n    }\n \n    private void performLongRunningTask() {\n        // 模拟长时间操作\n        try {\n            Thread.sleep(5000);  // 模拟耗时任务\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n \n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        handlerThread.quit();  // 退出HandlerThread\n    }\n \n    @Override\n    public IBinder onBind(Intent intent) {\n        return null;  // 如果不是 Bound Service 返回null\n    }\n}\nAI写代码\njava\n运行\n\n3.3 使用 IntentService 处理异步任务\nIntentService 是 Service 的一个子类，它专门用于处理异步请求，并且是自带一个工作线程来处理耗时任务。任务处理完毕后，IntentService 会自动停止。\n\npublic class MyIntentService extends IntentService {\n \n    public MyIntentService() {\n        super(\"MyIntentService\");\n    }\n \n    @Override\n    protected void onHandleIntent(@Nullable Intent intent) {\n        // 处理任务的逻辑\n        performLongRunningTask();\n    }\n \n    private void performLongRunningTask() {\n        // 模拟长时间操作\n        try {\n            Thread.sleep(5000);  // 模拟耗时任务\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\nAI写代码\njava\n运行\n\n启动 IntentService：\n\nIntent intent = new Intent(this, MyIntentService.class);\nstartService(intent);\nAI写代码\njava\n运行\n4. 注意事项\n在服务中执行长时间运行的任务时，应该考虑资源管理，避免占用过多电量或内存。\n一般情况下，Foreground Service 优先级最高，普通 Service优先级较低，容易被系统回收。如果需要后台运行的 Service 在用户看不见时不被系统杀死，可以使用Foreground Service，显示一个持续的通知。\n三、BroadcastReceiver：处理广播消息\nBroadcastReceiver 是 Android 中用于接收系统或应用发送的广播消息的组件。广播机制是 Android 中用于跨应用或跨进程通信的方式，应用可以通过广播发送和接收消息。\n\n1. 功能\n接收系统广播，如电量低、网络状态变化等。\n接收应用内广播，用于不同模块之间的消息传递。\n 2. BroadcastReceiver的工作原理\n当某个事件发生时，系统或应用会通过发送一个 Intent 来广播该事件。所有注册了相关广播事件的BroadcastReceiver都可以接收到这个广播，并在广播到达时执行预定义的任务。\n\n基本工作流程如下：\n\n广播发送方：通过sendBroadcast()、sendOrderedBroadcast()或sendStickyBroadcast()方法发送广播。\n广播接收方：通过注册的BroadcastReceiver接收相应的广播。\n处理逻辑：在BroadcastReceiver的onReceive()方法中，处理接收到的广播消息。\n3. BroadcastReceiver的注册方式\n3.1 静态注册\n静态注册的 BroadcastReceiver 是在AndroidManifest.xml中声明的，通常用于接收设备启动、安装应用、网络变化等系统级广播，即使应用未启动，仍然可以接收到广播。\n\n<receiver android:name=\".MyBroadcastReceiver\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.BOOT_COMPLETED\"/>\n    </intent-filter>\n</receiver>\nAI写代码\nXML\n3.2 动态注册\n动态注册的BroadcastReceiver是在代码中通过registerReceiver()方法进行的，适用于应用在运行期间才需要监听的事件。\n\npublic class MainActivity extends AppCompatActivity {\n    private MyBroadcastReceiver myReceiver;\n \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n \n        myReceiver = new MyBroadcastReceiver();\n        IntentFilter filter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);\n        registerReceiver(myReceiver, filter);  // 动态注册广播接收器\n    }\n \n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        unregisterReceiver(myReceiver);  // 动态注册的广播接收器需及时解除\n    }\n}\nAI写代码\njava\n运行\n\n4. BroadcastReceiver的生命周期\nBroadcastReceiver的生命周期很短，通常在广播到来时会触发onReceive()方法，处理完成后即终止。广播接收器并不需要一直运行。\n\nonReceive()：当广播到达时调用，可以根据广播的内容执行相应的操作。\n5. 广播的收发\nAndroid 提供了多种广播收发形式，分别适合不同的应用场景。广播通常通过Intent进行传递，接收者可以注册特定的广播接收器（BroadcastReceiver）来监听广播事件。\n\n5.1 标准广播（Normal Broadcast）\n标准广播是通过sendBroadcast()方法发送的。它是并发执行的，所有匹配的BroadcastReceiver同时接收广播，不保证接收顺序。\n\n发送标准广播：\n\nIntent intent = new Intent(\"com.example.CUSTOM_BROADCAST\");\nsendBroadcast(intent);  // 发送标准广播\nAI写代码\njava\n运行\n接收标准广播：通过动态或静态方式注册广播接收器来接收广播。\n\n动态注册：\npublic class MyBroadcastReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // 处理广播\n        Toast.makeText(context, \"Received broadcast!\", Toast.LENGTH_SHORT).show();\n    }\n}\n \npublic class MainActivity extends AppCompatActivity {\n    private MyBroadcastReceiver myReceiver;\n \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        myReceiver = new MyBroadcastReceiver();\n        IntentFilter filter = new IntentFilter(\"com.example.CUSTOM_BROADCAST\");\n        registerReceiver(myReceiver, filter);  // 动态注册广播接收器\n    }\n \n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        unregisterReceiver(myReceiver);  // 动态注册的广播需要解除注册\n    }\n}\nAI写代码\njava\n运行\n\n静态注册：\n<receiver android:name=\".MyBroadcastReceiver\">\n    <intent-filter>\n        <action android:name=\"com.example.CUSTOM_BROADCAST\"/>\n    </intent-filter>\n</receiver>\nAI写代码\nXML\n5.2 有序广播（Ordered Broadcast）\n有序广播是通过sendOrderedBroadcast()方法发送的，它允许多个接收器按优先级顺序接收广播。高优先级的接收器可以截断广播或修改广播数据，广播按照优先级从高到低传递。\n\n发送有序广播：\n\nIntent intent = new Intent(\"com.example.CUSTOM_ORDERED_BROADCAST\");\nsendOrderedBroadcast(intent, null);  // 发送有序广播\nAI写代码\njava\n运行\n接收有序广播：接收有序广播的BroadcastReceiver可以通过setResultData()等方法修改广播数据，并决定是否继续将广播传递给下一个接收器。\n\npublic class MyOrderedBroadcastReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String resultData = getResultData();  // 获取前一个接收器设置的结果数据\n        setResultData(\"Modified by receiver!\");  // 修改广播内容\n        Toast.makeText(context, \"Ordered broadcast received\", Toast.LENGTH_SHORT).show();\n    }\n}\nAI写代码\njava\n运行\n通过priority属性设置广播接收器的优先级，值越高优先级越高。\n\n<receiver android:name=\".MyOrderedBroadcastReceiver\">\n    <intent-filter>\n        <action android:name=\"com.example.CUSTOM_ORDERED_BROADCAST\"/>\n        <priority android:value=\"100\"/>\n    </intent-filter>\n</receiver>\nAI写代码\njava\n运行\n5.3 静态广播\n静态广播是通过在AndroidManifest.xml文件中声明广播接收器实现的。静态注册的广播接收器可以在应用未启动的情况下接收广播，常用于监听设备启动、电池状态等系统广播。\n\n<receiver android:name=\".BootReceiver\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.BOOT_COMPLETED\"/>\n    </intent-filter>\n</receiver>\nAI写代码\nXML\nBOOT_COMPLETED 是设备启动完成后系统发送的广播，静态注册的接收器可以在设备重启后自动执行操作。\n\n 6. 本地广播（LocalBroadcast）\n在Android中，也可以使用LocalBroadcastManager发送本地广播。相比于全局广播，本地广播只在应用内部传递，效率更高，并且不会泄露数据给其他应用，安全性更好。\n\n使用本地广播： \n\n1.注册本地广播接收器：\n\nLocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(this);\nIntentFilter filter = new IntentFilter(\"com.example.LOCAL_BROADCAST\");\nlocalBroadcastManager.registerReceiver(myReceiver, filter);\nAI写代码\njava\n运行\n2.发送本地广播：\n\nIntent localIntent = new Intent(\"com.example.LOCAL_BROADCAST\");\nLocalBroadcastManager.getInstance(this).sendBroadcast(localIntent);\nAI写代码\njava\n运行\n3.解除注册： \n\nLocalBroadcastManager.getInstance(this).unregisterReceiver(myReceiver);\nAI写代码\njava\n运行\n7. 监听系统广播\nAndroid 系统会在特定的事件发生时发送系统广播，应用程序可以通过注册广播接收器来监听这些事件。\n\n7.1 监听网络变更广播\nConnectivityManager.CONNECTIVITY_ACTION是网络连接状态变化时系统发送的广播。当设备从离线变为在线或网络状态发生变化时，应用可以接收此广播并执行相应操作。\n\n定义一个网络广播的接收：\n\npublic class NetworkChangeReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);\n        NetworkInfo networkInfo = cm.getActiveNetworkInfo();\n        \n        if (networkInfo != null && networkInfo.isConnected()) {\n            Toast.makeText(context, \"Network Connected\", Toast.LENGTH_SHORT).show();\n        } else {\n            Toast.makeText(context, \"Network Disconnected\", Toast.LENGTH_SHORT).show();\n        }\n    }\n}\nAI写代码\njava\n运行\n\n 动态注册广播接收器：\n\n@Override\nprotected void onStart() {\n    super.onStart();\n    \n    // 创建广播接收器\n    NetworkChangeReceiver networkChangeReceiver = new NetworkChangeReceiver();\n    IntentFilter filter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);\n     // 注册接收器\n    registerReceiver(networkChangeReceiver, filter);\n}\n \n@Override\nprotected void onStop() {\n    super.onStop();\n     // 注销接收器\n    unregisterReceiver(networkChangeReceiver);\n}\n \nAI写代码\njava\n运行\n\n7.2监听分钟到达广播\nACTION_TIME_TICK是系统每分钟发送一次的广播，常用于在应用中处理与时间相关的功能，比如更新 UI 上的时间显示。\n\n定义一个分钟广播的接收器：\n\npublic class TimeTickReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Toast.makeText(context, \"Minute passed\", Toast.LENGTH_SHORT).show();\n    }\n}\nAI写代码\njava\n运行\n 由于ACTION_TIME_TICK是频繁触发的广播，在Android 8.0及之后，静态注册无法接收此类广播。必须使用动态注册的方式。\n\n@Override\nprotected void onStart() {\n    super.onStart();\n    \n    TimeTickReceiver timeTickReceiver = new TimeTickReceiver();\n    IntentFilter filter = new IntentFilter(Intent.ACTION_TIME_TICK);\n    registerReceiver(timeTickReceiver, filter);\n}\n \n@Override\nprotected void onStop() {\n    super.onStop();\n    unregisterReceiver(timeTickReceiver);\n}\nAI写代码\njava\n运行\n\n7.3 监听系统闹钟广播\nAlarmManager可以设置定时任务，定时到达后系统会发送广播进行唤醒。通过设置闹钟，我们可以使用AlarmManager来调度任务，并通过BroadcastReceiver监听定时任务触发的广播。\n\n定义一个闹钟广播的接收器：\n\npublic class AlarmReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // 处理闹钟到达事件\n        Toast.makeText(context, \"Alarm received!\", Toast.LENGTH_SHORT).show();\n    }\n}\nAI写代码\njava\n运行\n 设置定时器：\n\n// 从系统服务中获取闹钟管理器\nAlarmManager alarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);\n// 创建一个广播事件的意图\nIntent intent = new Intent(this, AlarmReceiver.class);\n// 创建一个用于广播的延迟意图\nPendingIntent pendingIntent = PendingIntent.getBroadcast(this, 0, intent, 0);\n// 设置一个5秒后触发的闹钟\nlong triggerTime = System.currentTimeMillis() + 5000;\nalarmManager.setExact(AlarmManager.RTC_WAKEUP, triggerTime, pendingIntent);\nAI写代码\njava\n运行\n 静态注册广播接收器：\n\n<receiver android:name=\".AlarmReceiver\"/>\nAI写代码\nXML\n7.4 监听开机启动广播\nBOOT_COMPLETED是设备启动后系统发送的广播，用于执行设备重启后的任务（如启动服务、初始化数据等）。需要注意，接收此广播必须在 AndroidManifest.xml 中静态注册，并且应用需要声明权限。\n\n定义一个分钟广播的接收器：\n\npublic class BootReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        if (Intent.ACTION_BOOT_COMPLETED.equals(intent.getAction())) {\n            // 处理设备启动完成后的操作\n            Toast.makeText(context, \"Device booted\", Toast.LENGTH_SHORT).show();\n        }\n    }\n}\nAI写代码\njava\n运行\n静态注册广播接收器：\n\n<uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\"/>\n \n<receiver android:name=\".BootReceiver\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.BOOT_COMPLETED\"/>\n    </intent-filter>\n</receiver>\nAI写代码\nXML\n8. 权限与安全性\n某些广播，尤其是系统广播，需要在AndroidManifest.xml中声明权限。此外，广播的安全性也很重要。如果广播包含敏感信息或需要保护，应该避免使用全局广播。相反，使用本地广播或通过限制广播权限来保护广播内容。\n\n四、ContentProvider：应用间共享数据\nContentProvider 是 Android 提供的用于跨应用共享数据的组件。通过 ContentProvider，一个应用可以提供数据供其他应用访问，并控制数据的权限和访问方式。系统内置了很多 ContentProvider，比如访问联系人、媒体文件等。\n\n1. 功能\n在应用间共享数据，提供标准的接口供其他应用访问。\n支持 CRUD（增删改查）操作，允许其他应用按需读取、更新、删除数据。\n 2. ContentProvider的结构\nContentProvider提供了操作数据的基本接口，主要包括以下方法：\n\nonCreate()：初始化数据库，通常在这个方法中你会创建或打开SQLite 数据库。\nquery()：返回一个Cursor对象，供查询数据使用。\ninsert()：插入新的数据，返回新插入行的URI。\nupdate()：更新已有数据，根据条件返回更新的行数。\ndelete()：删除数据，根据条件删除并返回受影响的行数。\ngetType()：返回MIME类型，表示该URI对应的是单条数据还是多条数据。\n3. ContentProvider的注册方式\nContentProvider必须在AndroidManifest.xml中静态注册。系统在需要的时候会自动初始化该ContentProvider。\n\n<provider\n    android:name=\".MyContentProvider\"\n    android:authorities=\"com.example.provider\"\n    android:exported=\"true\" />\nAI写代码\nXML\nandroid:authorities：定义该ContentProvider的授权名，其他应用通过这个名称访问它。\nandroid:exported：如果设置为true，表示允许其他应用访问；设置为false时，只能供本应用访问。\n4. 访问ContentProvider的数据\n应用要访问ContentProvider提供的数据，需要通过ContentResolver来执行增删改查操作。\n\nquery()：从内容提供器中检索数据。\ninsert()：向内容提供器中插入新的数据行。\nupdate()：修改内容提供器中的现有数据。\ndelete()：从内容提供器中删除数据。\n5. ContentProvider中的URI机制\n在ContentProvider中，数据是通过URI来定位的。每个ContentProvider都有一个唯一的 URI，它由以下几个部分组成：\n\ncontent://<authority>/<path>/<id>\nAI写代码\nphp\n运行\ncontent://：URI 的协议部分，固定为content://。\n<authority>：表示该 ContentProvider 的授权名，通常是应用的包名。\n<path>：表示数据的路径，通常是表名。\n<id>：可选项，指定要操作的数据的ID。\n在操作数据时，不同的URI可以用于标识特定的数据集或单条数据，区分全表查询和单行查询。\n\n6. 常见的系统 ContentProvider\nAndroid系统自带了一些常见的ContentProvider，开发者可以通过这些ContentProvider访问系统级数据。\n\n6.1 通讯录（ContactsProvider）\nURI：content://contacts/\n用途：访问设备中的联系人信息。\nCursor cursor = getContentResolver().query(ContactsContract.Contacts.CONTENT_URI, null, null, null, null);\nAI写代码\njava\n运行\n6.2 媒体库（MediaStore）\nURI：content://media/external/\n用途：访问设备中的音频、视频、图片等媒体文件。\nCursor cursor = getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, null, null, null, null);\nAI写代码\njava\n运行\n6.3 日历（CalendarProvider）\nURI：content://com.android.calendar/\n用途：访问设备中的日历事件和日程。\nCursor cursor = getContentResolver().query(CalendarContract.Events.CONTENT_URI, null, null, null, null);\nAI写代码\njava\n运行\n7. 安全性与权限控制\n由于ContentProvider可能涉及多个应用的数据共享，安全性问题非常重要。为了保证数据的安全，Android提供了以下方式来保护ContentProvider。\n\n7.1 声明权限：\n可以通过声明权限来控制谁能够访问ContentProvider。在AndroidManifest.xml中，你可以通过android:permission属性来限制对 ContentProvider 的访问。\n\n<provider\n    android:name=\".MyContentProvider\"\n    android:authorities=\"com.example.provider\"\n    android:permission=\"com.example.permission.ACCESS_PROVIDER\" />\nAI写代码\nXML\n7.2 自定义权限：\n开发者可以在AndroidManifest.xml中定义自定义权限： \n\n<permission android:name=\"com.example.permission.ACCESS_PROVIDER\" android:protectionLevel=\"normal\" />', 0, '2025-06-20 15:18:03', '2025-06-20 16:30:08', NULL);
INSERT INTO `article` VALUES ('9fed5004-29ad-4b58-824d-674b30661e1a', 'b98070a4-ca31-4739-9d3f-d239b6f36a34', 'cat004', '【Java学习】Java基础知识和核心概念', 'Java基础知识和核心概念', '一、Java概述\n1.Java是什么？\nJava是一门面向对象的编程语言，作为静态面向对象编程语言的代表，很好地实现了面向对象的各种特性，如封装、继承、多态等，能够以简洁、优雅的方式处理复杂的编程问题。不仅如此，Java还是一个完整的技术体系，涵盖了从开发工具、编译器、虚拟机到应用运行环境的一整套技术支持。Java不仅在传统软件开发领域占据重要地位，还广泛应用于嵌入式系统、移动开发、企业级应用等多个行业，是一门非常优秀的编程语言。\n\n2.Java的发展史\nJava的前身是Oak，由詹姆斯·高斯林（James Gosling）于1991年在Sun Microsystems（后来被甲骨文公司收购）开发。起初，Oak是为了开发一种能够运行在多种设备上的程序，特别是家用电子设备和嵌入式系统。然而，随着互联网的兴起，Oak项目被重新定位为一种面向网络的编程语言，并在1995年正式更名为Java。\n\n1995年5月，Java 1.0正式发布，这标志着Java语言及其平台的正式诞生。Java 1.0引入了Java平台的核心特性，包括Java虚拟机（JVM）、Java编程语言、Java API等。Java的设计初衷是“一次编写，到处运行”（Write Once, Run Anywhere, WORA），这一理念极大地推动了Java的普及和应用。\n\n3.Java的特点\n面向对象：Java是纯粹的面向对象编程语言，几乎所有内容都以对象和类的形式存在。面向对象的特性包括封装、继承、多态，使得代码更易于维护、扩展和复用。\n\n跨平台性：Java的跨平台能力源自其在不同系统上运行的Java虚拟机（JVM）。Java代码被编译为字节码（bytecode），然后通过JVM在不同的平台上运行，而无需重新编译代码。\n\n安全性：Java设计之初就特别注重安全性。它提供了多层次的安全机制，允许开发人员创建健壮的、抵御潜在攻击的应用程序。尤其是在网络传输、远程操作等应用场景中，Java的安全机制得到了广泛使用。\n\n垃圾回收机制：Java具有自动的垃圾回收系统（Garbage Collection, GC），它能够帮助开发者管理内存，减少手动处理内存泄漏和指针操作带来的复杂性。\n\n丰富的类库和API：Java提供了丰富的标准类库，包括用于数据结构、I/O操作、网络编程、多线程、GUI等方面的API。这些类库极大地提升了开发效率，简化了许多常见功能的实现。\n\n多线程支持：Java内置对多线程的支持，能够轻松处理并发任务。开发者可以使用线程管理并发任务，提高程序的响应速度和处理能力。\n\n广泛应用领域：Java不仅被用于桌面应用和Web开发，还广泛应用于移动应用（Android使用Java作为主要开发语言之一）、企业级系统开发、大数据处理（如Hadoop）和物联网（IoT）。', 1, '2025-06-20 15:16:32', '2025-06-20 15:16:32', NULL);
INSERT INTO `article` VALUES ('ae469822-cb4d-4544-b31f-8efc0263fbfa', '6e6b7608-4e0b-4f8d-a169-47c5026adbd2', 'cat008', '舌尖上的城市灵魂：这10道美食，藏着中国最地道的文化密码', '\"吃一口，就懂一座城。\"从北京烤鸭的皇家烟火到重庆火锅的沸腾江湖，从武汉热干面的码头豪情到苏州一碗面的文人雅趣，这些舌尖上的城市名片，用味觉书写着最生动的中国故事。', '“吃一口，就懂一座城。”\n\n在中国，美食从来不只是填饱肚子的存在。一碗热干面，能尝出武汉人“过早”的江湖气；一口火锅，能涮出重庆的豪爽热辣；一片烤鸭，能卷起北京六百年的皇家烟火……食物是城市最生动的文化名片，更是穿越时空的“活历史”。今天，我们就来盘一盘那些“一口入魂”的城市代表美食，看看它们如何用味觉讲述一座城的故事。\n\n一、北京烤鸭：帝王气与市井味的完美融合\n\n“不到长城非好汉，不吃烤鸭真遗憾。”北京烤鸭的诞生，藏着皇城根下的“双重性格”。明代迁都时，南京的焖炉烤鸭技术传入北方，与山东的“炙鸭”结合，诞生了挂炉烤鸭的雏形。清代御厨改良技法，用果木炭火赋予鸭肉独特香气，成就了“宫廷御膳”的巅峰。\n\n\n但烤鸭真正“飞入寻常百姓家”，要感谢全聚德。1864年，河北人杨全仁在前门开了第一家烤鸭店，用“鸭皮蘸白糖”的吃法惊艳全城。如今，北京人吃烤鸭既讲究“片鸭108刀”的精致，也爱胡同里配着黄瓜、大葱的接地气。正如作家老舍所说：“烤鸭是北京的魂，一半在紫禁城，一半在胡同口。”\n\n二、重庆火锅：沸腾的江湖气\n\n“在重庆，鸳鸯锅是对外地人最后的温柔。”这座山城的性格，全在一锅红汤里翻腾。火锅的起源充满江湖气——长江边的码头工人将牛下水丢进麻辣烫底涮煮，既驱寒又解乏。抗战时期，文化名流云集重庆，火锅从街头登上大雅之堂，郭沫若甚至为万州烤鱼写下诗句：“天生一道佳肴菜，舍身满足人间美。”\n\n\n重庆人吃火锅的仪式感堪称一绝：毛肚要“七上八下”，鸭肠要“三提三摆”，最后必须用一碗冰粉收尾。这种“麻辣鲜香”不仅是味觉体验，更是敢爱敢恨、率真豪迈的城市精神。\n\n三、武汉热干面：过早文化的灵魂图腾\n\n武汉人把吃早餐称为“过早”，而热干面就是这场晨间仪式的绝对主角。20世纪30年代，汉口长堤街的摊贩蔡明纬将碱水面煮熟拌油，意外发明了这种“边走边吃”的快餐。芝麻酱的醇香、萝卜丁的脆爽、香油的绵密，在筷子飞速搅拌中交融，像极了武汉人“快准狠”的生活节奏。\n\n\n作家池莉在《热也好冷也好活着就好》中写道：“武汉人把命都交给了过早。”一碗热干面，盛着码头文化的务实，也藏着九省通衢的包容——正如热干面里可以加牛肉、加虾仁，武汉总能接纳八方来客。\n\n四、扬州早茶：江南文人的精致哲学\n\n“早上皮包水，晚上水包皮。”扬州人的雅致，从一笼蟹黄汤包开始。作为淮扬菜的发源地，扬州早茶讲究“食不厌精”：三丁包子要笋丁、鸡丁、肉丁黄金比例；千层油糕需折叠64层；文思豆腐要切出“发丝”般的细腻……这种极致追求，源自盐商鼎盛时期的“斗富”传统，更藏着《红楼梦》里“茄鲞”般的文人雅趣。\n\n\n联合国“世界美食之都”的称号，让扬州早茶成了活态非遗。正如美食家沈宏非所说：“在扬州吃早茶，吃的是千年文脉的舌尖续写。”\n\n五、西安羊肉泡馍：千年古都的碳水狂欢\n\n在西安，“掰馍两小时，吃馍五分钟”是本地人的倔强。泡馍的起源可追溯到西周“羊羹”，宋代夜市已有“入炉羊”的叫卖。最地道的吃法必须亲手将馍掰成黄豆大小，让每一粒面疙瘩吸饱羊汤的鲜香。\n\n\n这种对碳水的执着，源自十三朝古都的生存智慧——古代守城将士用干粮泡汤果腹，演化成今日的“馍都”盛景。贾平凹在《陕西小吃小识录》中调侃：“西安人的胃，是用面粉夯实的。”\n\n六、苏州一碗面：把江南文化盛进碗里\n\n“苏州人吃面，吃的是山水画。”苏式面的精髓在“三烫”——碗烫、汤烫、面烫，浇头从虾仁鳝糊到焖肉爆鱼，竟有518种之多。这种极致讲究，源自明清时期“富甲天下”的底气：富商们竞相聘请名厨，把一碗面做出“文人画”的意境。\n\n\n《风味人间》拍摄苏式面时感叹：“这不是面，是姑苏城的时光标本。”连面馆的“暗语”都充满雅趣——“宽汤”指多放汤，“重青”是多加蒜叶，仿佛在吟一首饮食版的《枫桥夜泊》。\n\n七、潮州牛肉丸：华侨乡愁的弹性记忆\n\n一颗合格的潮汕牛肉丸，必须能当乒乓球打！这种“弹牙”的功夫，藏着潮汕人闯荡四海的基因。19世纪，下南洋的潮汕人将传统捶打技艺带到东南亚，用牛后腿肉经3000次捶打成糜，让肉丸既紧实又爆汁。\n\n\n如今，潮汕牛肉火锅店开遍全球，成为华侨的“乡愁解药”。美食家蔡澜曾说：“潮州人的团结，全在那一锅牛骨清汤里。”\n\n八、开封灌汤包：北宋夜市的千年回响\n\n“提起像灯笼，放下似菊花。”开封灌汤包的绝技，源自《东京梦华录》记载的北宋夜市。当时“王楼山洞梅花包子”名动汴京，如今开封人仍坚持用三肥七瘦的馅料，让汤汁在薄如纸的皮中荡漾。\n\n\n咬开包子的瞬间，仿佛穿越到张择端《清明上河图》中的虹桥码头——这里曾是世界最大的不夜城，而灌汤包正是市井繁华的滋味见证。\n\n九、顺德双皮奶：岭南匠心的甜蜜密码\n\n“食在广州，厨出凤城。”顺德人用一碗双皮奶征服世界。水牛奶经两次炖煮形成独特奶皮，这种看似简单的甜品，考验着对火候的精准把控。2014年顺德成为中国第二个“世界美食之都”，双皮奶正是其申报的“秘密武器”。\n\n\n《寻味顺德》导演陈晓卿说：“这里的厨师能把平凡食材点石成金，就像岭南人总能在夹缝中创造奇迹。”\n\n十、延吉冷面：边疆民族的冰雪浪漫\n\n零下20℃吃冷面？延吉人用冰碗盛汤，加入苹果片、牛肉和辣酱，在极寒中吃出火热。这种朝鲜族美食，记录着长白山下的生存智慧——冬季用冰窖储存荞麦，夏季以酸汤解暑。\n\n\n当《舌尖上的中国》镜头对准延吉时，导演说：“一碗冷面，盛着东北亚的文化交融史。”\n\n食物是活着的历史，味道是流动的乡愁。 从皇城根到江湖码头，从江南园林到塞北雪原，每一道城市美食都在讲述着人与土地的故事。下次旅行时，不妨跟着味蕾去探寻——毕竟，读懂一座城的最好方式，就是先吃透它的胃。', 1, '2025-06-20 23:31:01', '2025-06-20 23:31:01', NULL);
INSERT INTO `article` VALUES ('ceaa08a5-ce99-4dcb-9b8d-2254cc18d4b9', 'b26b0f97-8477-4ccf-abe6-3fa9f6df8574', 'cat009', '为什么一直在说稳就业，但找工作却越来越难了呢？', '为什么一直在说稳就业，但找工作却越来越难了呢？', '因为教育错配导致的。*但凡掌握流利的中英文听说读写，会微积分线性代数概率等基础数学，精通5门编程语言，知道基本的网络，前后端，数据库，云服务，AI等现代知识，能看懂github源代码，也可以复现没有开源的论文，懂自媒体流量运作，会炒股票，懂得各种金融理财产品和投资方法，会上YouTube/b站，自学各种高精尖科技，懂得商业基本规律，知道如何做跨境电商，如何填写海关申报单。知道如何招聘和管理员工，如何带团队，如何融资，如何接待客户，如何制定公司管理规范和章程。熟悉各国税务和法律，知道如何开展跨国业务，知道如何优化成本，知道如何进行询价采购，知道如何进行商业谈判，知道如何解决民事纠纷。\n\n知道如何找到客户痛点，知道如何对产品定价，如何敬酒，如何吹捧领导，如何哄客户，如何培养新人，如何制定商业战略，如何进行财务规划。是怎么会失业的？*而以上内容几乎都无法在学校内掌握，但却是社会运作的核心。目前的高等教育就像个输卵管，大学生，甚至研究生毕业了和胚胎没啥区别，压根做不了什么有用的事。对整个社会的生产基本无法做出有用贡献。甚至还需要不停输养才能保持一个看似正常的存活状态。\n\n*目前这个世界的知识已经成指数爆炸，但学校教的内容可以说和十年前没有太多区别。不是说这些东西没用，而是大学里每门课的知识量太少，压根没必要学一学期，两天就可以学完一门课，七天就应该精通了。\n\n*很多人压根就没有自己理解问题，处理问题的能力，总是等着催着才能动一下。*你应该去想我如何才能做点有用的事，然后想办法去解决其中所有的困难，把事情做成，做好，做到极致，做到天下第一。而不是傻不拉几地认为毕业就该有工作。*还有就业是创业拉动的，而创业是投资催化的，在一个全民考公，投资萎靡，几乎没人创业的社会是不可能产生大量就业的。', 1, '2025-06-20 14:56:33', '2025-06-20 14:56:33', NULL);
INSERT INTO `article` VALUES ('d6ddfe26-cad9-4f8d-a162-ab8245c5275c', '3a37be4a-41c4-4bb8-9462-6e1971ff7e40', 'cat003', '我和男朋友说生孩子是他亏欠我的，之后他给我回了这么一大段，是我的问题吗？', '我和男朋友说生孩子是他亏欠我的，之后他给我回了这么一大段，是我的问题吗？', '简单介绍一下，谈恋爱之前我本身不打算生孩子，谈恋爱后给男朋友说这件事之后他说他想要孩子，然后如果我是这个想法的话就没必要和他继续下去，但是觉得他很好，所以为了他我愿意婚后去生孩子\n\n现在到谈婚论嫁的阶段了，我和男朋友说生孩子是他亏欠我的之后我们吵了一架然后他给我回了这么一大段，想问一下大家的看法，是我的问题吗？\n\n\n\n我总结了你的想法和我的想法 我感觉咱俩的重点存在差异 我挨着说明\n\n你的重点是觉得你生孩子付出的太多了，觉得是我亏欠你\n\n我的重点在你生孩子确实付出了很多，但是不能否认我也做了很多而只提你的不容易，我做的这么多一直到你愿意生孩子，我认为你觉得我的付出到你可以生孩子的程度，这某种程度上是我们达成的一个共识，我一直都知道生孩子很辛苦，也知道你决定的不容易，但是我不认为也不喜欢听我亏欠你，如果你觉得这个共识是你忍痛割爱施舍给我的，那我觉得你没必要忍痛割爱，我也不喜欢被施舍。\n\n我在尽力做到我能做的最好的去去达到你的要求，我做完这些我觉得因为是你要求的你想要的所以我要做到不会觉得你亏欠我\n\n反过来说你生孩子也是某种程度去满足我的要求，我也不希望你觉得我亏欠你\n\n如果你真的觉得你生孩子我做再多也是亏欠了你的话，我真的认为我们不适合走进婚姻，因为你心里总觉得你本来不需要孩子，生下这个孩子你这辈子有点不顺心就会觉得没生这个孩子多好，而我这辈子在你面前也抬不起头来，因为你给我生了孩子，而我是亏欠你的。我可以做到一直对你好，好好去照顾你，但不是因为我亏欠你，而是因为我喜欢你我爱你把你当成一家人发自内心去做的，不需要用亏欠来束缚。除此之外我一直觉得孩子是两个人的结晶，你说是给我生的那他以后也不可能只给我养老。希望你好好想想吧', 1, '2025-06-20 14:49:43', '2025-06-20 14:49:43', NULL);
INSERT INTO `article` VALUES ('df5e0ef2-3259-4b1e-8d0d-c76ef489cd9b', 'b98070a4-ca31-4739-9d3f-d239b6f36a34', 'cat004', 'Java I/O 深度解析：从基础到高级应用', 'Java I/O（输入/输出）是Java编程中最基础也是最重要的部分之一，它负责处理程序与外部世界的数据交换。无论是读写文件、网络通信还是处理用户输入，都离不开Java I/O系统。本文将全面介绍Java I/O的核心概念、主要类和使用技巧。', '引言\nJava I/O（输入/输出）是Java编程中最基础也是最重要的部分之一，它负责处理程序与外部世界的数据交换。无论是读写文件、网络通信还是处理用户输入，都离不开Java I/O系统。本文将全面介绍Java I/O的核心概念、主要类和使用技巧。\n\n一、Java I/O 基础\n1.1 流的概念\nJava I/O基于\"流\"（Stream）的概念。流可以看作是一个连续的数据序列，分为：\n\n输入流：从数据源读取数据（如文件、网络等）\n\n输出流：向目标写入数据\n\n所有流都实现了java.io包中的基本接口：\n\nInputStream / OutputStream（字节流）\n\nReader / Writer（字符流）\n\n1.2 字节流 vs 字符流\n特性	字节流	字符流\n基本类	InputStream/OutputStream	Reader/Writer\n处理单位	字节(8位)	字符(16位Unicode)\n典型用途	二进制数据(图片、视频等)	文本数据\n自动编码转换	无	支持(可指定字符集)\n二、核心I/O类详解\n2.1 文件操作类\njava\n// 文件读写示例\ntry (FileInputStream fis = new FileInputStream(\"input.txt\");\n     FileOutputStream fos = new FileOutputStream(\"output.txt\")) {\n    byte[] buffer = new byte[1024];\n    int bytesRead;\n    while ((bytesRead = fis.read(buffer)) != -1) {\n        fos.write(buffer, 0, bytesRead);\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}\n2.2 缓冲流\n缓冲流通过内置缓冲区减少实际I/O操作次数，显著提高性能：\n\njava\n// 使用缓冲流\ntry (BufferedReader reader = new BufferedReader(new FileReader(\"input.txt\"));\n     BufferedWriter writer = new BufferedWriter(new FileWriter(\"output.txt\"))) {\n    String line;\n    while ((line = reader.readLine()) != null) {\n        writer.write(line);\n        writer.newLine();\n    }\n}\n2.3 对象序列化\nJava通过ObjectInputStream和ObjectOutputStream实现对象序列化：\n\njava\n// 序列化对象\nclass Person implements Serializable {\n    private String name;\n    private int age;\n    // 构造方法、getter/setter省略\n}\n\ntry (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"person.dat\"))) {\n    oos.writeObject(new Person(\"张三\", 25));\n}\n三、NIO (New I/O)\nJava 1.4引入的NIO提供了非阻塞I/O和更高效的缓冲区管理：\n\n3.1 核心组件\nChannels：连接文件的通道（FileChannel、SocketChannel等）\n\nBuffers：数据容器（ByteBuffer、CharBuffer等）\n\nSelectors：多路复用器，用于非阻塞I/O\n\n3.2 文件复制示例\njava\ntry (FileChannel source = new FileInputStream(\"source.txt\").getChannel();\n     FileChannel dest = new FileOutputStream(\"dest.txt\").getChannel()) {\n    dest.transferFrom(source, 0, source.size());\n}\n四、高级主题\n4.1 内存映射文件\njava\nRandomAccessFile file = new RandomAccessFile(\"largefile.dat\", \"rw\");\nMappedByteBuffer buffer = file.getChannel().map(\n    FileChannel.MapMode.READ_WRITE, 0, file.length());\n\n// 直接操作内存映射区域\nbuffer.put(0, (byte) \'J\');\nbuffer.put(1, (byte) \'A\');\nbuffer.put(2, (byte) \'V\');\nbuffer.put(3, (byte) \'A\');\n4.2 文件锁定\njava\ntry (FileChannel channel = new RandomAccessFile(\"data.txt\", \"rw\").getChannel()) {\n    FileLock lock = channel.lock(); // 排他锁\n    try {\n        // 执行写操作\n    } finally {\n        lock.release();\n    }\n}\n五、最佳实践\n始终关闭资源：使用try-with-resources语句\n\n选择合适的缓冲大小：通常8KB是个不错的起点\n\n考虑字符编码：明确指定字符集（如UTF-8）\n\n大文件处理：考虑使用NIO或内存映射文件\n\n异常处理：区分可恢复错误和不可恢复错误\n\n六、Java I/O性能优化\n缓冲是关键：未缓冲的I/O操作非常慢\n\n减少系统调用：批量读写优于单字节操作\n\n直接缓冲区：NIO的直接缓冲区可减少拷贝开销\n\n并行处理：对于大文件可考虑分块并行处理\n\n结语\nJava I/O系统提供了丰富的API来处理各种I/O场景。理解不同I/O类的特性和适用场景，能够帮助我们编写出更高效、更健壮的代码。随着Java版本的演进，I/O API也在不断改进（如Java 7的Files类、Java 11的改进等），开发者应当持续关注这些变化。\n\n希望本文能帮助你更好地理解和应用Java I/O。如果你有任何问题或建议，欢迎在评论区留言讨论。', 1, '2025-06-20 15:21:46', '2025-06-20 16:31:03', NULL);
INSERT INTO `article` VALUES ('ef2b4cae-90fe-4e8d-b7ee-863a916cf710', 'b98070a4-ca31-4739-9d3f-d239b6f36a34', 'cat004', 'Java 的下载安装教程', '安装 Java', '说明：\n\n本文介绍的是 Windows 下安装 Java 的方法。对于 Linux 下 Java 的安装，可见笔者的另一篇博客：\n\n\n在 Linux 操作系统中安装 Java：\nhttps://blog.csdn.net/wangpaiblog/article/details/120093325\n\n笔者维护本教程期间的历史安装环境：\n\n安装成功过的 Java：\n\nJava 21\n\nJava 17\n\nJava 11\n\nJava 8\n\n安装成功时的 Windows：\n\nWindows 10 教育版\n安装 Java 就是安装 JDK。Java 有三大分支，这里选择的是 Java SE。关于这些分支的区别，可见笔者的另一篇博客：\n\nJava SE、OpenJDK、Java EE、Java 框架、Java ME 等概念之间的区别：\nhttps://blog.csdn.net/wangpaiblog/article/details/112342415\n\n此外，对于 JDK，也更替了很多个版本，其中也分为 LTS 版本和非 LTS 版本。LTS 指长期支持版（Long Term Support）。对于这个概念，这里不多作解释，读者可以简单将它们理解为稳定版与快照版。\n\n（Java 的 LTS 版本目前有：Java 8、Java 11、Java 17、Java 21。网址：https://www.oracle.com/java/technologies/java-se-support-roadmap.html）\n\n笔者的意见是，最好下载最新的 LTS 版本。但对于一些刚刚学习 Java 的读者来说，下载哪个版本区别不大，因为它们之间的区别不会在简单的 Java 程序中体现。笔者最后编写本教程的时候， 下载的是当时的最新 LTS 版 Java SE 21。\n\n进入 Oracle 官网下载 Java SE，也就是 JDK 的安装包。\n\nJava 的官网下载链接：https://www.oracle.com/java/technologies/downloads/\n\nJava 21 下载处的最终网址：https://www.oracle.com/java/technologies/downloads/#jdk21-windows\n\n（在 Java 17 以前，下载还需要注册一个 Oracle 账号。但在 Java 17 之后，Oracle 决定推出商业免费版。也许是担忧 Java 的市场份额每况愈下，垄断看来不够格。对于 Java 17，下载不需要注册账号，但之前的版本仍然需要。）\n\n因为是国外的网站，所以可能网站加载缓慢。部分浏览器可能禁用此网站上的某些控件，所以如下的过程如果发现网站上缺失某些界面选项，可以试试换个浏览器。\n\n\n\n【说明】\n\n  在前面的下载中，可以看到，Windows 下的 JDK 数据包有三种可选的下载：Windows x64 Compressed Archive、Windows x64 Installer 和 Windows x64 MSI Installer。其中，前者为 JDK 的免安装版本，后两者均为 JDK 的离线安装包版本，其中一个是 WIndows 的 EXE 安装包，另一个是 MSI 安装包。这两种安装包没有太大的区别，这里使用的是 EXE 安装包。\n\n  也可以选择 JDK 的免安装版。很多“免安装”狂热者很喜欢选择任何软件的免安装版本。不过，由于这两者没有本质上的区别，没有任何理由非要使用免安装版本。通常，使用离线安装包版本能减少很多麻烦。\n\n下载好了之后应该有一个名叫 jdk-21_windows-x64_bin.exe 的安装包。运行安装包，这里 JDK 的默认路径是 C:\\Program Files\\Java\\jdk-21\\。当然，读者也可以改为自己喜欢的路径。请记住这个路径，下面会用上。如图：\n\n\n\n\n\n这一步完成之后就可以开始设定 Path 路径了，进行这一步是为了能在 Windows 的 CMD 中识别出 C:\\Program Files\\Java\\jdk-21 下 Java 的相关命令。\n\n这要进入 Windows 的环境变量界面（这里以 Win10 教育版为例），如图（请顺着图片用鼠标点击画红圈部分）：\n\n\n\n\n\n\n\n这里需要在 Path 中填写 Java 的命令工具的路径。不过在这之前，需要先创建环境变量 JAVA_HOME。设置 JAVA_HOME 的值为 C:\\Program Files\\Java\\jdk-21。这个路径实际上就是前面安装 Java 的路径。\n\n（如果电脑不打算设置多用户，则这里选择 用户变量 还是 系统变量 的 Path 区别不大。这里选择 用户变量。）\n\n\n\n\n\n在设置完 JAVA_HOME 之后，在 Path 中添加新的一行 %JAVA_HOME%\\bin。\n\n\n\n\n\n【Q & A】\n\n  阅读本教程的很多读者可能是初次学习编程，他们看到此处时可能有如下这些疑问。笔者将这些疑问解答于此。如果这些疑问没有覆盖全部的问题，也可以在下方留言提问。\n\n  这些问题与 Java 安装没有必然的联系，如果读者暂时不想了解这些内容，可以先收藏本博客，然后跳过这些内容，日后再来阅读。\n\nQ1：在前面涉及的文件路径可以改为自己喜欢的路径吗？\n\nA1：当然可以。在软件开发中，基本上所有的文件路径都是可以改的，也都是不能随便乱改的。路径本质上只是为了能找到需要的资源。能不能改主要取决于读者对原理熟不熟悉，应不应该改则取决于读者在安全和效率上的考量。在软件开发中流行一句话，“约定大于配置”。有时候使用默认设定会有好处。\n\n对于笔者来言，在软件开发中更改默认路径主要有两个考虑，一是统一标准，二是为了安全。统一标准是为了避免自己以后在没有技术含量的地方踩坑耽误时间。而安全指的是，在很多文件系统中，不同文件路径的权限是不同的。虽然都是同一电脑上的文件路径，但有些路径是安全的，有些则不能保证。有时候为了安全，笔者会改为自己设置的安全地址。\n\nQ2：环境变量 Path 有什么用？为什么要设置？\n\nA2：这个问题解释起来很复杂，限于篇幅，这里简单解释一下。我们知道，使用 Java 之前要先安装，但使用 Java 的应用并不在乎 Java 有没有安装，实际上，它们也无法知道 Java 有没有安装。它们只是需要使用 Java 的一些命令（如 java、javac 等），这些命令对应着 Java 安装目录下的一些可执行程序。如果设置了环境变量，它们就可以借助操作系统来使用 Java 的命令，否则，对它们而言就相当于没有安装 Java。\n\n在 Windows 中，如果设置了环境变量 Path，则这些命令的来源（路径）可以通过输入命令 where 来找到，如：\n\nwhere java\n\nC:\\Users\\XXX>where java\nC:\\Program Files\\Common Files\\Oracle\\Java\\javapath\\java.exe\nC:\\Program Files\\Java\\jdk-21\\bin\\java.exe\nAI写代码\ncmd\n1\n2\n3\n如果想知道关于环境变量 Path 更多的信息，可见笔者的另一篇博客：\n\nWindows 中的环境变量 Path 的作用：\nhttps://blog.csdn.net/wangpaiblog/article/details/113622196\n\nQ3：环境变量是什么？为什么要设置？\n\nA3：环境变量是操作系统提供的一种简易的、对应用公开的键值数据库。它可以用来存放某应用想要传达给其它应用或记录给自己的信息。可以理解为每个应用自己主动设置的 QQ 签名。\n\n特别地，对于环境变量 Path，它特指可执行文件的绝对路径。其中，该可执行文件的文件名将作为可在 CMD 中输入的命令名。如果不使用环境变量 Path，则执行这些命令时需要输入全路径。其它应用往往只知道所需的命令名，而不知道所需应用的路径，所以需要提前设置环境变量 Path。\n\nQ4：为什么要同时设置 JAVA_HOME 与 Path？\n\nA4：对于简单的 Java 程序来说，实际上只需要将 Java 的命令工具的路径添加至 Path 中即可（对于简单的 Java 程序来说，实际上只需要设置 Path：C:\\Program Files\\Java\\jdk-21\\bin\\）。不过，很多依赖 Java 的工具技术还要求设置其它环境变量，如 JAVA_HOME，而且这个环境变量非常常用，因此这里选择在安装时就予以配置。换句话说，如果其它工具技术还要求设置更多环境变量，那就还需要单独配置。\n\n环境变量并不是配置的越多越好，冗余是万恶之首，请按需配置。\n\nQ5：环境变量 Path 与 JAVA_HOME 有什么区别？\n\nA5：关于这方面的内容，可见笔者的另一篇博客：\n\n  Windows 中的环境变量 Path 与 XXXX_HOME 的区别：\nhttps://blog.csdn.net/wangpaiblog/article/details/112644073\n\nQ6：为什么非要手动配置环境变量，为什么 Java 不让安装包来完成这些操作呢？\n\nA6：让安装包在安装时自动设置环境变量是一件很简单的事情（任何人使用一种 安装包制作工具 就可以做到这一点），Oracle 没有选择这么做主要是为了给用户提供更多的自由。用户有可能会在电脑上安装很多个版本 JDK，如果让安装包自动完成这项工作，这将影响用户原来设置的环境变量，因此安装包没有提供这项功能。\n\n并不是所有的安装程序都不会帮用户设置环境变量，实际上，很多应用程序的安装包都会选择帮用户进行这种设定。帮用户设置环境变量一方面可以方便用户，另一方面则会污染操作系统中的环境变量。类似的问题还发生在 WIndows 中的注册表，如果每个应用没有自觉进行合理的使用，那么整个注册表将成为一个垃圾堆。\n\nQ7：环境变量 CLASSPATH 是什么？为什么很多教程都写要加这个环境变量？\n\nA7：关于网上其它教程的质量，这里不作评价。首先，对于 JDK 1.4 及以前的版本，才需要配置环境变量 CLASSPATH。它的作用是指定运行 Java 程序所需的 .class 文件，以及运行所需的 JDK 包（dt.jar、tools.jar）。这涉及 Java 类加载器的类加载机制，此处不做过多介绍。\n\nQ7.1：用户所编写的 Java 程序的源文件的位置是不确定的，为什么可以预先设定呢？\n\nA7.1：可以在环境变量的路径值中使用 . 来表示当前路径。\n\nQ7.2：为什么不把这个设定提前融入到 JDK 中呢？\n\nA7.2：很遗憾，在 JDK 1.4 及以前，就是没有提供这样的功能。要知道，JDK 1.4 是 2002 年发布的，而 2001 年 Windows XP 才发布。对于 JDK 1.5 及之后的版本，也可以不用配置 CLASSPATH。\n\nQ8：为什么安装完 Java 之后无法在安装目录下像其它软件一样双击直接打开？\n\nA8：安装的 Java 软件实际上只是一个 Java 代码的运行环境。一行代码都没有编写怎么会打得开呢？\n\nQ8.1：可是，有些 IDE 不就可以直接打开吗？如果软件不能打开要怎么编写代码？\n\nA8.1：编写代码本质上不需要 Java。代码只是一个文本，直接用记事本编写也可以（虽然不推荐这样做），运行 Java 代码才需要 Java。没有向 Java 提供代码，Java 不可能运行的。\n\n至于 IDE 为什么能直接打开的问题，必须要理解，Java 与 Java 的 IDE 是不同的东西。Java 代码只有在编写的时候才可能需要 IDE，它运行的时候本质上是不需要 IDE 的。冗余是万恶之首，不需要的功能就不应该内置，所以 Java 没有内置 IDE。而 IDE 是第三方提供的功能，与 Java 官方无关。IDE 实际上是一种高级代码编辑器，它运行 Java 代码实际上还是需要 Java 的运行环境。因此，IDE 有没有提供 GUI 界面、编写 Java 代码的功能，这跟 Java 的运行没有必然关系。\n\n总而言之，安装 Java 环境是为了运行 Java 代码的。Java 的 IDE 是为了编写、运行 Java 代码的。IDE 能不能打开跟 Java 能不能直接打开没有直接关系。\n\nQ8.1.1：你说的“向 Java 提供代码”要怎么完成？\n\nA8.1.1：对于运行 Java 代码，IDE 通常提供了这一功能，建议直接使用 IDE 完成。本文只是 Java 的下载安装教程，不是 Java 的入门教程，故此处不作介绍。\n\n有些导师特别喜欢凡事从底层开始教学，有时候这样做确实有道理。但大多数人学 Java 是为了吃饭的，而不是研究学术。凡事有轻重缓急，建议学习 Java 直接从在 IDE 内编写代码开始，不要从记事本、Java 命令、命令行开始。笔者从来没听说过哪个奥运会运动员会花大把的时间来研究人类的直立行走。\n\n当然，在命令行使用 Java 命令运行 Java 程序也不难，只是有些繁琐。但据笔者的观察，很多初学者有惯性思维以及喜欢浅尝辄止。他们在刚开始学会使用命令行之后会在很长一段时间都停留在这一阶段。有些甚至引以为豪，认为使用命令行这种原始的工具才是高级和专业的象征。这里不讨论到底原始代不代表高级，笔者只是想说，技术最终只是用来吃饭的，每种技术都有各自的专长和局限性，没有什么高低贵贱之分。考虑到工作效率，能用 IDE 的尽量使用 IDE。对于不支持使用 IDE 的环境，也要熟悉命令行的操作。\n\nQ8.1.2：那为什么 Java 没有像 IDE 这样的 GUI 界面呢？\n\nA8.1.2：你这个问题问到了编程的本质，因此这不是一种简单的问题，限于篇幅，这里就两点简单解释一下，后续读者随着编程经验的积累自然就懂了。\n\n第一，不是什么程序都是需要 GUI 界面的。程序的划分方式有很多种，如前台和后台，前端和后端。像后台、后端这种一般都是不需要 GUI 界面的。实际上，一台计算机中绝大多数的程序都是不需要 GUI 界面的。原因有很多，很多程序不能让用户来控制，用户也不希望被打扰。另外，GUI 程序都是非常占用内存的。完全不能让每个程序都装载 GUI 界面。\n\n前面已经说明，Java 环境只是来运行 Java 程序的，运行程序根本不需要额外的 GUI 界面。在商业生产环境下，使用傻瓜的 UI 界面启动程序不仅更繁琐，而且还会影响启动效率。冗余是万恶之首，不需要的功能就不应该内置，所以 Java 程序的运行没有内置 GUI 引导界面。但安装 Java 的引导界面还有（实际上这也不是必要的）。因为此界面只在安装时启动，所以不会影响运行时的效率。\n\n第二，我们是开发者，不是普通的用户。造汽车的人可能坐在汽车里面造汽车吗？肯定不能，因为从逻辑上，造汽车必定要使用比汽车更原始的工具，不能用汽车造汽车。同样的道理，我们是开发者，必定要经常和原始的工具打交道，所以不能指望在傻瓜的 GUI 界面上点点点就可以实现编程。\n\nQ9：Java 为什么不能在安装时内置 IDE？\n\nA9：你认为每个人都喜欢在新买的电脑上看到 360 吗？\n\n标准的环境变量为：\n\n变量名：JAVA_HOME\n\n变量值：C:\\Program Files\\Java\\jdk-21\n\n变量名：Path\n\n变量值：%JAVA_HOME%\\bin\n\n以上如果设置完成之后，进入 CMD 中输入 java 或 javac 后，应该会出现篇幅很长的说明文字，这说明前面的设置生效了。而之所以出现这些说明文字，是因为输入这些命令的时候没有输入任何参数，这种情况下，命令在运行后会提示此命令的语法格式。如果前面的设置不成功，则 CMD 会告知输入了它不认识的命令名。\n\n进入 CMD 的方法有很多，这里只举一例。使用快捷键 Win + R 打开 运行，然后输入 cmd：\n\n\n\n\n\n\n\n设置完成之后，就可以安装关于 Java 的集成开发工具 IDE 了。主流的 IDE 有 IntelliJ IDEA、Eclipse 、MyEclipse、NetBeans 等。这些软件简介如下：\n\nIntelliJ IDEA：\n\nJava 中功能最强大的 IDE。主流企业除非抵制等特殊原因，使用的都是该软件。一种观点认为，如果一个企业的 Java 开发如果没有使用该软件，而是 Eclipse，可以考虑换一家了。如果使用的是其它 IDE，可以连夜提桶跑路了。\n\nIntelliJ IDEA 的下载安装非常傻瓜，不再另开博客作介绍。但很遗憾，该软件不是免费的。\n\nIntelliJ IDEA 在 2021 年之后的版本已经以插件的形式给出了 IntelliJ IDEA 的官方汉化版。该插件名为：Chinese (Simplified) Language Pack。而在 2024 年之后的版本取消了插件的形式，而改为在设置中开启。\n\nIntelliJ IDEA 官网：https://www.jetbrains.com/idea/\n\nIntelliJ IDEA 历史版本下载：https://www.jetbrains.com/idea/download/other.html\n\nEclipse：\n\n一款多年来一直流行的官方 Java IDE，支持官方汉化，完全免费。笔者在学生时代使用的第一款 Java 的 IDE 就是它。\n\n关于 Eclipse 的中文简体版下载安装教程，可见笔者的另一篇博客：\n\nEclipse 的中文简体版安装教程：\nhttps://blog.csdn.net/wangpaiblog/article/details/111502047\n\n其它：\n\n如果你在使用其它 Java IDE，或者打算使用手机、 CMD 进行编程，请尽快改掉这个坏习惯。因为就算笔者不此提醒，你也迟早会被迫使用 IDE 进行开发。而以软件工程的角度来说，任何漏洞越晚被发现，所带来的损失越大。研究底层不要以这种方法。这种方法就像是钻木取火、骑马登山。\n\n最后的最后，考虑到很多读者可能是初次学习编程，为了减少可能会走的弯路，笔者还编写了如下博客。欢呼吧，少年！\n\n编程开发使用的软件大全：https://blog.csdn.net/wangpaiblog/article/details/112760795\n\n编程开发使用的辅助软件大全：https://blog.csdn.net/wangpaiblog/article/details/115223210\n\n编程开发涉及的非原生英文名词的读法：https://blog.csdn.net/wangpaiblog/article/details/115019684\n\nMaven 和 Gradle 官方文档及相关资料的网址集合：https://blog.csdn.net/wangpaiblog/article/details/132706244\n\nSpring 官方文档及相关资料的网址集合：https://blog.csdn.net/wangpaiblog/article/details/131881448', 1, '2025-06-20 15:19:43', '2025-06-20 16:31:03', NULL);
INSERT INTO `article` VALUES ('fab0518f-182e-4686-b4bb-74b955bd56cc', 'abdb3d00-749e-4189-8370-0f66e10fb728', 'cat007', '与柬埔寨参议院主席通话录音遭泄露，泰国总理致歉', '【环球时报特约记者 王逸】当地时间19日，泰国总理佩通坦就其与柬埔寨参议院主席洪森的通话录音遭泄露一事致歉，泰柬边界争端也因此变得更加复杂。', '据泰国《国家报》19日报道，当天在与泰国军方领导人紧急会晤后，佩通坦在新闻发布会上表示：“我必须对所发生的事情道歉，因为我真的不知道谈话被录音了。”她向公众保证，泰国政府将与军队团结一致，捍卫泰国的领土完整。她强调：“我们没有时间内斗。我们必须保护我们的主权。政府已准备好以各种方式支持军队。”佩通坦还说：“从现在开始，我会更加谨慎地说话。只要我们团结一致，就能度过这场危机。”\n\n5月28日，泰柬两国军队在边境争议地区发生短暂冲突，双方交火持续约10分钟，1名柬埔寨士兵身亡。《国家报》称，洪森18日公布了一段佩通坦和他的通话录音。佩通坦在通话中请求洪森协助缓解两国边境的紧张局势，并称不要理睬泰国陆军第二军区司令的言行，后者站在泰国和柬埔寨政府的“对立面”。泰国陆军第二军区负责泰柬边境地区的安全。\n\n此次通话被泄露令佩通坦尴尬不已。佩通坦在18日的新闻发布会上承认通话录音属实，但强调自己只是在试图解决两国边境争议。她还表示，通话属于私人性质且不应被泄露。\n\n19日，泰国外交部就佩通坦与洪森通话内容遭泄露一事，正式向柬埔寨驻泰国大使递交外交抗议照会。泰外交部强调，柬方行为不可接受，严重损害两国互信。泰国军方19日则发表声明，强调与政府的团结。\n\n另据泰国通讯社19日报道，泰国上议院军事与安全事务委员会宣布，将向法院和国家反腐委员会递交请愿书，要求罢免佩通坦。同一天，泰国反对党呼吁解散国会，举行新选举。此前一天，执政联盟第二大党自豪泰党宣布退出佩通坦领导的执政联盟，担任部长职务的该党成员向总理提出辞职。该党敦促佩通坦为录音造成的损害承担责任。\n\n路透社19日称，随着主要执政联盟伙伴退出，佩通坦政府岌岌可危，执政仅10个月的她面临越来越大的辞职压力。联泰建国党和民主党19日宣布分别召开会议，商讨下一步行动。如果这两个党决定退出执政联盟，佩通坦将不得不组建少数派政府。\n\n另据泰国《曼谷邮报》19日报道，抗议者当天在泰国政府大楼附近聚集，要求佩通坦辞职。此次集会由“泰国改革学生和人民网络”领导。政府大楼周围戒备森严，警察用人墙封路，阻止抗议者进入政府大楼。', 1, '2025-06-20 15:09:56', '2025-06-20 15:09:56', NULL);

-- ----------------------------
-- Table structure for article_category
-- ----------------------------
DROP TABLE IF EXISTS `article_category`;
CREATE TABLE `article_category`  (
  `id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '类别ID',
  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '类别名称（如小说、论文、日常）',
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '类别描述',
  `create_time` datetime(0) NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `name`(`name`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '文章类别表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article_category
-- ----------------------------
INSERT INTO `article_category` VALUES ('cat002', '论文', '学术研究论文，包括期刊论文、学位论文等', '2023-01-02 11:00:00');
INSERT INTO `article_category` VALUES ('cat003', '日常', '日常生活记录、随笔和感悟', '2023-01-03 09:30:00');
INSERT INTO `article_category` VALUES ('cat004', '技术博客', '关于编程、技术和开发的博客文章', '2023-01-05 14:20:00');
INSERT INTO `article_category` VALUES ('cat005', '旅行游记', '旅行经历和景点介绍的游记', '2023-01-10 16:45:00');
INSERT INTO `article_category` VALUES ('cat006', '诗歌散文', '诗歌、散文等文学作品', '2023-01-15 13:10:00');
INSERT INTO `article_category` VALUES ('cat007', '新闻资讯', '时事新闻和热点资讯', '2023-02-01 08:00:00');
INSERT INTO `article_category` VALUES ('cat008', '美食烹饪', '食谱分享和烹饪技巧', '2023-02-05 12:30:00');
INSERT INTO `article_category` VALUES ('cat009', '趣事讨论', '有趣的事情讨论', '2023-02-05 12:30:00');

-- ----------------------------
-- Table structure for article_comment
-- ----------------------------
DROP TABLE IF EXISTS `article_comment`;
CREATE TABLE `article_comment`  (
  `id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '评论ID',
  `user_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '评论用户ID',
  `article_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '文章ID',
  `parent_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '父评论ID（NULL表示顶级评论）',
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '评论内容',
  `create_time` datetime(0) NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '评论时间',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `user_id`(`user_id`) USING BTREE,
  INDEX `article_id`(`article_id`) USING BTREE,
  INDEX `parent_id`(`parent_id`) USING BTREE,
  CONSTRAINT `article_comment_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE CASCADE ON UPDATE RESTRICT,
  CONSTRAINT `article_comment_ibfk_2` FOREIGN KEY (`article_id`) REFERENCES `article` (`id`) ON DELETE CASCADE ON UPDATE RESTRICT,
  CONSTRAINT `article_comment_ibfk_3` FOREIGN KEY (`parent_id`) REFERENCES `article_comment` (`id`) ON DELETE SET NULL ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '文章评论表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article_comment
-- ----------------------------
INSERT INTO `article_comment` VALUES ('08e38f85-9c54-4c58-ab64-c015c6e7ad24', 'b98070a4-ca31-4739-9d3f-d239b6f36a34', '8bb4c2ad-8d46-42c9-af4c-99ccede8b7b9', '557c4d45-7541-4c9c-99b9-ab68577209a6', '私你了', '2025-06-20 23:40:43');
INSERT INTO `article_comment` VALUES ('2283caf3-ee8e-4514-9b6a-09df55097a7c', 'b98070a4-ca31-4739-9d3f-d239b6f36a34', '08860d1b-883b-4997-a3b8-464f90569dd5', NULL, '美国怎么这么贱', '2025-06-20 23:39:34');
INSERT INTO `article_comment` VALUES ('3eb0362b-25b6-4e4d-9529-b888dc026698', '6e6b7608-4e0b-4f8d-a169-47c5026adbd2', 'ae469822-cb4d-4544-b31f-8efc0263fbfa', NULL, '北京烤鸭帝王气与市井味的完美融合', '2025-06-20 23:31:59');
INSERT INTO `article_comment` VALUES ('4cf4385e-1baa-4594-ac22-daaf883a3eba', 'fa34f0e6-2ad2-4170-ab95-15165cfea936', 'ceaa08a5-ce99-4dcb-9b8d-2254cc18d4b9', NULL, '现在工作确实很难找了', '2025-06-20 23:28:34');
INSERT INTO `article_comment` VALUES ('557c4d45-7541-4c9c-99b9-ab68577209a6', 'fa34f0e6-2ad2-4170-ab95-15165cfea936', '8bb4c2ad-8d46-42c9-af4c-99ccede8b7b9', NULL, '谁来', '2025-06-20 23:28:15');
INSERT INTO `article_comment` VALUES ('7db7581e-f128-4379-874e-bb71a666233f', 'b98070a4-ca31-4739-9d3f-d239b6f36a34', '8bb4c2ad-8d46-42c9-af4c-99ccede8b7b9', '557c4d45-7541-4c9c-99b9-ab68577209a6', '11', '2025-06-20 23:40:38');
INSERT INTO `article_comment` VALUES ('9aed1711-064f-410d-b818-c2209dd26679', 'fa34f0e6-2ad2-4170-ab95-15165cfea936', '9fed5004-29ad-4b58-824d-674b30661e1a', 'c1120ca5-4370-4a5f-8f6e-7b3510c5dde4', '我的物理成为了我败笔', '2025-06-20 23:27:54');
INSERT INTO `article_comment` VALUES ('b6dbccb8-3dbc-4316-9474-b3ce5d16231a', 'b26b0f97-8477-4ccf-abe6-3fa9f6df8574', 'd6ddfe26-cad9-4f8d-a162-ab8245c5275c', NULL, '我觉得你们俩都有点强势了，男方潜意识里是强势的觉得自己对女方很好，不存在亏钱这一说，女方本来不想生孩子的但是生了，就总觉得男方亏欠自己', '2025-06-20 15:00:20');
INSERT INTO `article_comment` VALUES ('c1120ca5-4370-4a5f-8f6e-7b3510c5dde4', 'fa34f0e6-2ad2-4170-ab95-15165cfea936', '9fed5004-29ad-4b58-824d-674b30661e1a', NULL, '我终于懂了老年人面对手机时的无力感', '2025-06-20 23:27:15');
INSERT INTO `article_comment` VALUES ('c4084438-39c7-4f3c-b44d-1e6a91ada456', '4f29f9de-40f7-42ab-b17e-975082524c53', '8bb4c2ad-8d46-42c9-af4c-99ccede8b7b9', NULL, '谁要', '2025-06-20 23:42:19');
INSERT INTO `article_comment` VALUES ('c442d8a4-2876-4a0f-ab49-07f2443e9195', 'abdb3d00-749e-4189-8370-0f66e10fb728', '09c79bb4-5fac-4cbb-8c3e-de18fa214c5a', NULL, '这是我发布的第一篇文章，承蒙大家关照', '2025-06-20 14:43:27');
INSERT INTO `article_comment` VALUES ('c75d52ac-43b5-46f8-8f8e-df2732ecf08f', 'b98070a4-ca31-4739-9d3f-d239b6f36a34', '08860d1b-883b-4997-a3b8-464f90569dd5', '2283caf3-ee8e-4514-9b6a-09df55097a7c', '真服了', '2025-06-20 23:40:23');
INSERT INTO `article_comment` VALUES ('e7913a4b-d87f-47dc-9980-7281e6f7899c', 'fa34f0e6-2ad2-4170-ab95-15165cfea936', 'ceaa08a5-ce99-4dcb-9b8d-2254cc18d4b9', '4cf4385e-1baa-4594-ac22-daaf883a3eba', '我投了几十家，交换简历才三家', '2025-06-20 23:28:57');
INSERT INTO `article_comment` VALUES ('f57f1e6e-e901-4751-a3f7-51b46c661c9e', '4f29f9de-40f7-42ab-b17e-975082524c53', '8bb4c2ad-8d46-42c9-af4c-99ccede8b7b9', '557c4d45-7541-4c9c-99b9-ab68577209a6', '来', '2025-06-20 23:42:06');

-- ----------------------------
-- Table structure for article_favorite
-- ----------------------------
DROP TABLE IF EXISTS `article_favorite`;
CREATE TABLE `article_favorite`  (
  `id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '收藏ID',
  `user_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户ID',
  `article_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '文章ID',
  `create_time` datetime(0) NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '收藏时间',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `user_id`(`user_id`, `article_id`) USING BTREE COMMENT '用户对同一文章不可重复收藏',
  INDEX `article_id`(`article_id`) USING BTREE,
  CONSTRAINT `article_favorite_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE CASCADE ON UPDATE RESTRICT,
  CONSTRAINT `article_favorite_ibfk_2` FOREIGN KEY (`article_id`) REFERENCES `article` (`id`) ON DELETE CASCADE ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '文章收藏表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article_favorite
-- ----------------------------
INSERT INTO `article_favorite` VALUES ('289e950b-94ad-4b69-af29-b5dc77f67aed', 'b98070a4-ca31-4739-9d3f-d239b6f36a34', '37e6e538-908d-4d53-a122-a3f066df78c2', '2025-06-20 15:22:42');
INSERT INTO `article_favorite` VALUES ('479fac90-5434-4c8e-8e17-06cb4f66677b', 'd3e79691-81e4-4c88-92f9-5d822939bba5', '08860d1b-883b-4997-a3b8-464f90569dd5', '2025-06-21 00:18:09');
INSERT INTO `article_favorite` VALUES ('74e296bb-9ccf-4424-a43b-9764a2b3267c', 'b98070a4-ca31-4739-9d3f-d239b6f36a34', '09c79bb4-5fac-4cbb-8c3e-de18fa214c5a', '2025-06-20 15:22:39');
INSERT INTO `article_favorite` VALUES ('8a764120-9327-4876-8b42-f8ffc6961436', 'b26b0f97-8477-4ccf-abe6-3fa9f6df8574', '37e6e538-908d-4d53-a122-a3f066df78c2', '2025-06-20 15:01:28');
INSERT INTO `article_favorite` VALUES ('ee09101f-aa5e-42d9-b29c-459e1d1c44f0', 'abdb3d00-749e-4189-8370-0f66e10fb728', '09c79bb4-5fac-4cbb-8c3e-de18fa214c5a', '2025-06-20 14:43:45');
INSERT INTO `article_favorite` VALUES ('ee1d6601-e9a5-403f-a928-ea883d20568f', 'b98070a4-ca31-4739-9d3f-d239b6f36a34', '8bb4c2ad-8d46-42c9-af4c-99ccede8b7b9', '2025-06-20 23:41:36');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户ID',
  `username` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户名',
  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '昵称',
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '密码（加密存储）',
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '头像URL',
  `gender` tinyint(0) NULL DEFAULT 0 COMMENT '性别：0-未知，1-男，2-女',
  `phone` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '手机号',
  `email` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '邮箱',
  `role` tinyint(0) NULL DEFAULT 0 COMMENT '角色：0-普通用户，1-管理员',
  `is_enabled` tinyint(0) NULL DEFAULT 1 COMMENT '账号是否启用：0-禁用，1-启用',
  `create_time` datetime(0) NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '创建时间',
  `update_time` datetime(0) NULL DEFAULT CURRENT_TIMESTAMP(0) ON UPDATE CURRENT_TIMESTAMP(0) COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `username`(`username`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '用户表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('335a31c0-e1bf-4461-834e-c18aa6c18585', 'user03', 'Celine', '$2a$10$b8fGWBFbTplGdUwcynhlLey9yLY0JBZtkyEsY7iOu2qqE6c9qD21W', '/uploads/avatar_335a31c0-e1bf-4461-834e-c18aa6c18585_3a6caeec-65a6-469b-9946-f73ad2460ec5.jpg', NULL, NULL, '123@qq.com', 0, 1, '2025-06-20 14:51:36', '2025-06-20 14:52:02');
INSERT INTO `user` VALUES ('3a37be4a-41c4-4bb8-9462-6e1971ff7e40', 'user02', '湫兮如风', '$2a$10$kbLgrf96NaPum5GOwyCgO.qN4Jpwlcx0.Ri3wyk4QBkiXi6MbvZza', NULL, NULL, NULL, '123@qq.com', 0, 1, '2025-06-20 14:48:49', '2025-06-20 15:49:24');
INSERT INTO `user` VALUES ('4f29f9de-40f7-42ab-b17e-975082524c53', 'user09', '蒝味的微笑', '$2a$10$5Yq.WLlM/uPlkWuKasq3E./f.M7N9O0qhPcIxXzjUH5mfaX1bylom', NULL, 2, '', '123@qq.com', 0, 1, '2025-06-20 22:55:42', '2025-06-20 22:55:42');
INSERT INTO `user` VALUES ('5c86b482-0ee0-48e1-8621-d666255e1119', 'admin', 'admin', '$2a$10$1UzAEikdgcHnJrOV4hrRHuFltlYdURfYE.hot0CKzlFeNQmtCf6HS', NULL, 1, '', '123@qq.com', 1, 1, '2025-06-20 14:36:18', '2025-06-20 16:01:10');
INSERT INTO `user` VALUES ('6e6b7608-4e0b-4f8d-a169-47c5026adbd2', 'user07', '怎么能没有炸鸡和啤酒', '$2a$10$KiqmiR6M9lZYjf.ZS3VzHOVhKs0zKdO9Qgld.H6tJM3Ww2JOreULy', NULL, 1, '', '123@qq.com', 0, 1, '2025-06-20 22:54:06', '2025-06-20 22:54:06');
INSERT INTO `user` VALUES ('abdb3d00-749e-4189-8370-0f66e10fb728', 'user01', '环球新闻', '$2a$10$uyHLoWQO45fZVY58EE4D5.KS1j7xcJR2XWB362KIMHvCT72sx0aXG', '/uploads/avatar_abdb3d00-749e-4189-8370-0f66e10fb728_0a9f92ff-487a-4084-8233-def9fd478b91.png', 0, '', '123@qq.com', 0, 1, '2025-06-20 14:35:18', '2025-06-21 00:51:16');
INSERT INTO `user` VALUES ('b26b0f97-8477-4ccf-abe6-3fa9f6df8574', 'user04', 'Moenova', '$2a$10$k6scze2gk99FT8wi4FXVa.p09y/oIYVakzQ8T3gb9/Tp57.LnMMPG', '/uploads/avatar_b26b0f97-8477-4ccf-abe6-3fa9f6df8574_6fd6dee5-7267-4b2e-945f-16ca7a35633f.jpg', NULL, NULL, '123@qq.com', 0, 1, '2025-06-20 14:55:29', '2025-06-20 16:06:15');
INSERT INTO `user` VALUES ('b98070a4-ca31-4739-9d3f-d239b6f36a34', 'user05', 'Madalie', '$2a$10$qW1eQA9qOre08qknpa.kIebjmEEli8E1uUOSEbzpUBeVrNfoxWDe.', NULL, NULL, NULL, '123@qq.com', 0, 1, '2025-06-20 15:14:46', '2025-06-20 16:06:13');
INSERT INTO `user` VALUES ('baf1435f-6547-4ae8-8cd3-baea7d85a396', 'user06', 'xin21', '$2a$10$pEbtJQHGFih5PuWAxmXcuON1FKVhJSH0pWVP4kE8Md2xlqCWTwHFG', NULL, 1, '', '123@qq.com', 0, 0, '2025-06-20 15:51:23', '2025-06-20 16:06:20');
INSERT INTO `user` VALUES ('d3e79691-81e4-4c88-92f9-5d822939bba5', 'user11', '用户1750436213919', '$2a$10$VCyH8cWCI.eHlryAP5p5KeILhJC1MvDza5qP4Hgw.n1JiTAir6cZK', NULL, 1, '', '123@qq.com', 0, 1, '2025-06-21 00:16:54', '2025-06-21 00:16:54');
INSERT INTO `user` VALUES ('e7c5821c-bf86-4e88-8d99-7ffb575ce931', 'root', 'root', '$2a$10$0Eom8Riw6aeZIQ7VXk5jf.p5CxsX1xnz.LvMF0upRoWjT8fQCf/Ii', NULL, 1, '', '123@qq.com', 1, 1, '2025-06-20 16:01:36', '2025-06-20 16:01:36');
INSERT INTO `user` VALUES ('f20c0ca0-bc7e-4942-8f32-a2946ab7a2a5', 'user10', '栀子花开', '$2a$10$R8kjorkSQwoIx9coNNJKM.gUajEMah93AeW34rXc.miVkw1Uuf3DW', NULL, 1, '', '123@qq.com', 0, 1, '2025-06-20 22:56:46', '2025-06-20 22:56:46');
INSERT INTO `user` VALUES ('fa34f0e6-2ad2-4170-ab95-15165cfea936', 'user08', '隔壁家的姑娘', '$2a$10$zhOFgKGf5n9WZDCVwM7Pj.izlyN6/xPjSMQ0TYJqmtheBbKwVk0zy', NULL, 2, '', '123@qq.com', 0, 1, '2025-06-20 22:54:35', '2025-06-20 22:54:35');

SET FOREIGN_KEY_CHECKS = 1;
